---
title: "Intronic and junction overlapping read counts analyses"
author: "Ira Iosub"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    toc: yes
    toc_depth: 3
    toc_float: yes
    theme: paper
    highlight: monochrome
    df_print: paged
    code_folding: hide
  html_document:
    toc: yes
    toc_depth: '3'
    df_print: paged
---

```{r}
# Load the packages
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(cowplot))
suppressPackageStartupMessages(library(rtracklayer))
```

Set color scheme

```{r}
smoops_values = c("naive" = "#4682B4", "epiSC" = "#008080", diff = "#894c89")
control_values = c("naive" = "#bdcae2", "epiSC" = "#b1c7c9", diff = "#cdb7d1")
```

# Functions

```{r}
#' Calculate p-value for comparison of intronic read ratios between two groups
#'
#' This function calculates the p-value from a two-sample t-test comparing the
#' ratios of intronic reads to total reads (Intron_to_All_Ratio) between two groups.
#'
#' @param stage_data A data frame containing the intronic read ratios and group information.
#'        The data frame should have at least two columns: 'Intron_to_All_Ratio'
#'        (the ratio of intronic reads to all reads) and 'Group' (group labels for comparison).
#' @param group1 A character string specifying the label of the first group to compare.
#' @param group2 A character string specifying the label of the second group to compare.
#'
#' @return A numeric value representing the p-value from the t-test.
#'
#' @examples
#' # Example usage:
#' # Assuming 'data' is a data frame with columns 'Intron_to_All_Ratio' and 'Group'
#' # calculate_p_value(data, "control", "treated")
#'
calculate_p_value <- function(stage_data, group1, group2) {
  t.test(stage_data$Intron_to_All_Ratio[stage_data$Group == group1],
         stage_data$Intron_to_All_Ratio[stage_data$Group == group2])$p.value
}



#' Summarize junction read counts and perform statistical tests
#'
#' This function processes a data frame of junction read counts and computes the
#' junction-to-total read ratios. It summarizes the mean and standard deviation
#' of the ratio for each group and stage, and performs t-tests between specified
#' groups (oops vs control and semi vs control) within each stage.
#'
#' @param junction.df A data frame containing read count data. The data frame
#'        should include columns 'Sample', 'Junction_Overlapping_Reads', and 'Total_Reads'.
#'        The 'Sample' column should follow the format "group_stage".
#'
#' @return A data frame summarizing the junction-to-total read ratios with mean
#'         and standard deviation for each group and stage, along with p-values
#'         from t-tests comparing 'oops' vs 'control' and 'semi' vs 'control' within each stage.
#'
#' @details The function first splits the 'Sample' column into 'group' and 'stage',
#'          then calculates the ratio of junction-overlapping reads to total reads
#'          (Junction_to_All_Ratio). The function groups the data by 'group' and
#'          'stage' and computes the mean and standard deviation of the ratio.
#'          It also performs t-tests between the groups within each stage, specifically
#'          comparing 'oops' vs 'control' and 'semi' vs 'control'.
#'
#' @examples
#' # Example usage:
#' # Assuming 'data' is a data frame with columns 'Sample', 'Junction_Overlapping_Reads',
#' # and 'Total_Reads'
#' # summarise_junction_read_counts(data)
#'
summarise_junction_read_counts <- function(junction.df) {

  junction.df <- junction.df %>%
    rowwise() %>%
    mutate(group = str_split(Sample, "_")[[1]][1],
           stage = str_split(Sample, "_")[[1]][2]) %>%
    ungroup()

  junction.df$Junction_to_All_Ratio <- junction.df$Junction_Overlapping_Reads / junction.df$Total_Reads

  junction_summary.df <- junction.df %>%
    group_by(group, stage) %>%
    summarise(
      Mean_Ratio = mean(Junction_to_All_Ratio),
      SD_Ratio = sd(Junction_to_All_Ratio)
    )

  # Perform t-tests between groups within each stage
  t_test_results <- junction.df %>%
    group_by(stage) %>%
    summarise(
      p_value_Oops_vs_Control = t.test(Junction_to_All_Ratio[group == "oops"],
                                       Junction_to_All_Ratio[group == "control"])$p.value,
      p_value_Semi_vs_Control = t.test(Junction_to_All_Ratio[group == "semi"],
                                       Junction_to_All_Ratio[group == "control"])$p.value
    )

  junction_summary.df <- left_join(junction_summary.df, t_test_results, by = "stage")
  junction_summary.df <- junction_summary.df %>%
    mutate(p_value_Oops_vs_Control = case_when(group == "oops" ~ p_value_Oops_vs_Control,
                                               TRUE ~ NA),
           p_value_Semi_vs_Control = case_when(group == "semi" ~ p_value_Semi_vs_Control,
                                               TRUE ~ NA))

  junction_summary.df$stage <- factor(junction_summary.df$stage, levels = c("naive", "epiSC", "diff"))

  return(junction_summary.df)
}


#' Summarize intronic read counts and perform statistical tests
#'
#' This function processes a data frame of intronic read counts and computes the
#' intron-to-total read ratios. It summarizes the mean and standard deviation
#' of the ratio for each group and stage, and performs t-tests between specified
#' groups (oops vs control and semi vs control) within each stage.
#'
#' @param intronic.df A data frame containing read count data. The data frame
#'        should include columns 'Sample', 'Intron_Overlapping_Reads', and 'Total_Reads'.
#'        The 'Sample' column should follow the format "group_stage".
#'
#' @return A data frame summarizing the intron-to-total read ratios with mean
#'         and standard deviation for each group and stage, along with p-values
#'         from t-tests comparing 'oops' vs 'control' and 'semi' vs 'control' within each stage.
#'
#' @details The function first splits the 'Sample' column into 'group' and 'stage',
#'          then calculates the ratio of intron-overlapping reads to total reads
#'          (Intron_to_All_Ratio). The function groups the data by 'group' and
#'          'stage' and computes the mean and standard deviation of the ratio.
#'          It also performs t-tests between the groups within each stage, specifically
#'          comparing 'oops' vs 'control' and 'semi' vs 'control'.
#'
#' @examples
#' # Example usage:
#' # Assuming 'data' is a data frame with columns 'Sample', 'Intron_Overlapping_Reads',
#' # and 'Total_Reads'
#' # summarise_intronic_read_counts(data)
#'
summarise_intronic_read_counts <- function(intronic.df) {

  intronic.df <- intronic.df %>%
    rowwise() %>%
    mutate(group = str_split(Sample, "_")[[1]][1],
           stage = str_split(Sample, "_")[[1]][2]) %>%
    ungroup()

  intronic.df$Intron_to_All_Ratio <- intronic.df$Intron_Overlapping_Reads / intronic.df$Total_Reads

  intronic_summary.df <- intronic.df %>%
    group_by(group, stage) %>%
    summarise(
      Mean_Ratio = mean(Intron_to_All_Ratio),
      SD_Ratio = sd(Intron_to_All_Ratio)
    )

  # Perform t-tests between groups within each stage
  t_test_results <- intronic.df %>%
    group_by(stage) %>%
    summarise(
      p_value_Oops_vs_Control = t.test(Intron_to_All_Ratio[group == "oops"],
                                       Intron_to_All_Ratio[group == "control"])$p.value,
      p_value_Semi_vs_Control = t.test(Intron_to_All_Ratio[group == "semi"],
                                       Intron_to_All_Ratio[group == "control"])$p.value
    )

  intronic_summary.df <- left_join(intronic_summary.df, t_test_results, by = "stage")
  intronic_summary.df <- intronic_summary.df %>%
    mutate(p_value_Oops_vs_Control = case_when(group == "oops" ~ p_value_Oops_vs_Control,
                                               TRUE ~ NA),
           p_value_Semi_vs_Control = case_when(group == "semi" ~ p_value_Semi_vs_Control,
                                               TRUE ~ NA))

  intronic_summary.df$stage <- factor(intronic_summary.df$stage, levels = c("naive", "epiSC", "diff"))

  return(intronic_summary.df)
}
```

# Data: Read counts and annotations

```{r}
mm.gr <- rtracklayer::import.gff2("~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/ref/gencode.vM27.annotation.gtf.gz")

# Prepare the coordinates for smoops genes
genes.gr <- mm.gr[mm.gr$type == "gene"]
smoops.df <- master.df %>%
  dplyr::filter(control_common == F)
```


```{r}
master.df <- fread("~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/Master Dataset/all_smOOPS_and_controls_V2.tsv")

naive.smoops.df <- master.df %>%
  dplyr::filter(smoops_naive == T)

epi.smoops.df <- master.df %>%
  dplyr::filter(smoops_epi == T)

diff.smoops.df <- master.df %>%
  dplyr::filter(smoops_diff == T)

naive.smoops.gr <-genes.gr[genes.gr$gene_id %in% naive.smoops.df$gene_id]
naive.smoops.gr$score <- 0L
rtracklayer::export.bed(naive.smoops.gr, "~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/ref/read_counts_ref/naive_smoops.bed")

epi.smoops.gr <-genes.gr[genes.gr$gene_id %in% epi.smoops.df$gene_id]
epi.smoops.gr$score <- 0L
rtracklayer::export.bed(epi.smoops.gr, "~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/ref/read_counts_ref/epi_smoops.bed")

diff.smoops.gr <-genes.gr[genes.gr$gene_id %in% diff.smoops.df$gene_id]
diff.smoops.gr$score <- 0L
rtracklayer::export.bed(diff.smoops.gr, "~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/ref/read_counts_ref/diff_smoops.bed")

# Prepare intronic coordinates
all_regions.gr <- rtracklayer::import.gff2("~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/ref/regions_M27.gtf.gz")
all_introns.gr <- all_regions.gr[all_regions.gr$type == "intron"]
all_introns.gr$score <- 0
rtracklayer::export.bed(all_introns.gr, "~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/ref/read_counts_ref/introns.bed")

introns.gr <- all_introns.gr[all_introns.gr$gene_id %in% smoops.df$gene_id]
rtracklayer::export.bed(introns.gr, "~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/ref/read_counts_ref/smoops_introns.bed")
```



Read count data was obtained by running the following scripts: `get_stage_smoops_overlapped_read_counts.sh` and `get_all_overlapped_read_counts.sh` on NEMO

```{r}
# All reads
all.df <- fread("~/Documents/projects/mesc_analyses/read_counts/summary_combined.txt")
# smoops.df <- fread("~/Documents/projects/mesc_analyses/read_counts/smoops_combined_summary.txt")

colnames(all.df) <- c("Sample", "Total_Reads", "Junction_Overlapping_Reads", "Intron_Overlapping_Reads")
# colnames(smoops.df) <- c("Sample", "Total_Reads", "Intron_Overlapping_Reads", "Junction_Overlapping_Reads")

# Stage specific smoops overlapped read count data
naive.smoops.df <- fread("~/Documents/projects/mesc_analyses/read_counts/naive_smoops_summary.txt")
epi.smoops.df <- fread("~/Documents/projects/mesc_analyses/read_counts/epi_smoops_summary.txt")
diff.smoops.df <- fread("~/Documents/projects/mesc_analyses/read_counts/diff_smoops_summary.txt")

colnames(naive.smoops.df) <- c("Sample", "Total_Reads", "Intron_Overlapping_Reads", "Junction_Overlapping_Reads")
colnames(epi.smoops.df) <- c("Sample", "Total_Reads", "Intron_Overlapping_Reads", "Junction_Overlapping_Reads")
colnames(diff.smoops.df) <- c("Sample", "Total_Reads", "Intron_Overlapping_Reads", "Junction_Overlapping_Reads")
```


# Junction reads proportion (figure s1)

Higher junction-spanning read ratios (and optionally lower intronic read ratios) in a given assay suggest a greater prevalence of processed (mature) RNA. 

```{r}
# All reads
summary.junction.all.df <- summarise_junction_read_counts(all.df)


summary.junction.all.gg <- ggplot(summary.junction.all.df, aes(x = group, y = Mean_Ratio, fill = stage)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  geom_errorbar(aes(ymin = Mean_Ratio - SD_Ratio, ymax = Mean_Ratio + SD_Ratio), 
                width = 0.2, position = position_dodge(width = 0.8)) +
  ylab("Junction-to-total read ratio (all reads)") +
  xlab("") +
  facet_grid(~stage) +
  theme_cowplot() +
  theme(legend.title = element_blank(), axis.text.x = element_text(angle = 60, hjust = 1)) +

  # Add p-values for Oops vs Control, centered above horizontal lines
  geom_text(data = subset(summary.junction.all.df, !is.na(p_value_Oops_vs_Control)),
            aes(label = paste0("p = ", format(p_value_Oops_vs_Control, digits = 2)), 
                y = 0.325, x = 1.5), 
            size = 3.5, vjust = -0.5, 
            fontface = "italic", color = "black") +

  # Add p-values for Semi vs Control, centered above horizontal lines
  geom_text(data = subset(summary.junction.all.df, !is.na(p_value_Semi_vs_Control)),
            aes(label = paste0("p = ", format(p_value_Semi_vs_Control, digits = 2)), 
                y = 0.355, x = 2), 
            size = 3.5, vjust = -0.5, 
            fontface = "italic", color = "black") +

  # Draw the horizontal lines only once
  geom_segment(data = subset(summary.junction.all.df, group == "control"),
               aes(x = 1, xend = 2, y = 0.32, yend = 0.32), linewidth = 0.4) +
  geom_segment(data = subset(summary.junction.all.df, group == "control"),
               aes(x = 1, xend = 3, y = 0.35, yend = 0.35), linewidth = 0.4) +
  scale_x_discrete(labels = c("control" = "control", "semi" = "Semi-extractibility", "oops" = "OOPS")) +
  # ggtitle("All unique-mapping reads") +
  scale_fill_manual(values = control_values) +
    theme(
    strip.text = element_blank(),  # Remove facet labels
    strip.background = element_blank(),  # Remove facet boxes
    legend.title = element_blank(),  # Remove legend title
    axis.text.x = element_text(size = 9))

# smOOPs

# naive
naive.summary.junction.smoops.df <- summarise_junction_read_counts(naive.smoops.df%>% dplyr::filter(str_detect(Sample, "naive")))
# epi
epi.summary.junction.smoops.df <- summarise_junction_read_counts(epi.smoops.df%>% dplyr::filter(str_detect(Sample, "epi")))
# diff
diff.summary.junction.smoops.df <- summarise_junction_read_counts(diff.smoops.df%>% dplyr::filter(str_detect(Sample, "diff")))

summary.junction.smoops.df <- rbind(naive.summary.junction.smoops.df, epi.summary.junction.smoops.df, diff.summary.junction.smoops.df)

summary.junction.smoops.gg <- ggplot(summary.junction.smoops.df, aes(x = group, y = Mean_Ratio, fill = stage)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  geom_errorbar(aes(ymin = Mean_Ratio - SD_Ratio, ymax = Mean_Ratio + SD_Ratio),
                width = 0.2, position = position_dodge(width = 0.8)) +
  ylab("Junction-to-total read ratio (smOOPs reads)") +
  xlab("") +
  facet_grid(~stage) +
  theme_cowplot() +
  theme(legend.title = element_blank(), axis.text.x = element_text(angle = 60, hjust = 1)) +

  # Add p-values for Oops vs Control, centered above horizontal lines
  geom_text(data = subset(summary.junction.smoops.df, !is.na(p_value_Oops_vs_Control)),
            aes(label = paste0("p = ", format(p_value_Oops_vs_Control, digits = 2)),
                y = 0.225, x = 1.5),
            size = 3.5, vjust = -0.5,
            fontface = "italic", color = "black") +

  # Add p-values for Semi vs Control, centered above horizontal lines
  geom_text(data = subset(summary.junction.smoops.df, !is.na(p_value_Semi_vs_Control)),
            aes(label = paste0("p = ", format(p_value_Semi_vs_Control, digits = 2)),
                y = 0.255, x = 2),
            size = 3.5, vjust = -0.5,
            fontface = "italic", color = "black") +

  # Draw the horizontal lines only once
  geom_segment(data = subset(summary.junction.smoops.df, group == "control"),
               aes(x = 1, xend = 2, y = 0.22, yend = 0.22), linewidth = 0.4) +
  geom_segment(data = subset(summary.junction.smoops.df, group == "control"),
               aes(x = 1, xend = 3, y = 0.25, yend = 0.25), linewidth = 0.4) +
  scale_x_discrete(labels = c("control" = "control", "semi" = "Semi-extractibility", "oops" = "OOPS")) +
  # ggtitle("smOOPs unique-mapping reads") +
  scale_fill_manual(values = smoops_values) +
    theme(
    strip.text = element_blank(),  # Remove facet labels
    strip.background = element_blank(),  # Remove facet boxes
    legend.title = element_blank(),  # Remove legend title
    axis.text.x = element_text(size = 9))

junction.gg <- plot_grid(summary.junction.all.gg, summary.junction.smoops.gg, ncol = 2)
ggsave("~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/figures/figure_1/junction2total_ratio.pdf",
       junction.gg, dpi = 300, width = 14, height = 7)
```


# Intronic reads proportion

```{r}
# All reads
summary.intronic.all.df <- summarise_intronic_read_counts(all.df)

summary.intronic.all.gg <- ggplot(summary.intronic.all.df, aes(x = group, y = Mean_Ratio, fill = stage)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  geom_errorbar(aes(ymin = Mean_Ratio - SD_Ratio, ymax = Mean_Ratio + SD_Ratio),
                  width = 0.2, position = position_dodge(width = 0.8)) +
  ylab("Intron-to-total read ratio") +
  xlab("") +
  facet_grid(~stage) +
  theme_cowplot() +
  theme(legend.title = element_blank(), axis.text.x = element_text(angle = 60, hjust = 1)) +
  scale_fill_manual(values = control_values) +

  # Add p-values for Oops vs Control, centered above horizontal lines
  geom_text(data = subset(summary.intronic.all.df, !is.na(p_value_Oops_vs_Control)),
              aes(label = paste0("p = ", format(p_value_Oops_vs_Control, digits = 2)),
                  y = 0.655, x = 1.5),
              size = 3.5, vjust = -0.5,
              fontface = "italic", color = "black") +

  # Add p-values for Semi vs Control, centered above horizontal lines
  geom_text(data = subset(summary.intronic.all.df, !is.na(p_value_Semi_vs_Control)),
              aes(label = paste0("p = ", format(p_value_Semi_vs_Control, digits = 2)),
                  y = 0.685, x = 2),
              size = 3.5, vjust = -0.5,
              fontface = "italic", color = "black") +

  # Draw the horizontal lines only once
  geom_segment(data = subset(summary.intronic.all.df, group == "control"),
                 aes(x = 1, xend = 2, y = 0.65, yend = 0.65), linewidth = 0.4) +
  geom_segment(data = subset(summary.intronic.all.df, group == "control"),
                 aes(x = 1, xend = 3, y = 0.68, yend = 0.68), linewidth = 0.4) +
  scale_x_discrete(labels = c("control" = "control", "semi" = "Semi-extractibility", "oops" = "OOPS")) +
  theme(
    strip.text = element_blank(),  # Remove facet labels
    strip.background = element_blank(),  # Remove facet boxes
    legend.title = element_blank(),  # Remove legend title
    axis.text.x = element_text(size = 9)) +
  ggtitle("All unique-mapping reads")


# smOOPs

# naive
naive.summary.intronic.smoops.df <- summarise_intronic_read_counts(naive.smoops.df %>% dplyr::filter(str_detect(Sample, "naive")))

# epi
epi.summary.intronic.smoops.df <- summarise_intronic_read_counts(epi.smoops.df %>% dplyr::filter(str_detect(Sample, "epi")))

# diff
diff.summary.intronic.smoops.df <- summarise_intronic_read_counts(diff.smoops.df %>% dplyr::filter(str_detect(Sample, "diff")))

all.smoops.df <- rbind(naive.summary.intronic.smoops.df, epi.summary.intronic.smoops.df, diff.summary.intronic.smoops.df)
summary.intronic.smoops.gg <- ggplot(all.smoops.df,
                                     aes(x = group, y = Mean_Ratio, fill = stage)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.8)) +
  geom_errorbar(aes(ymin = Mean_Ratio - SD_Ratio, ymax = Mean_Ratio + SD_Ratio),
                width = 0.2, position = position_dodge(width = 0.8)) +
  ylab("Intron-to-total read ratio") +
  xlab("") +
  facet_grid(~stage, scales = "free_x") +
  theme_cowplot() +
  theme(legend.title = element_blank(), axis.text.x = element_text(angle = 60, hjust = 1)) +

  # Add p-values for Oops vs Control, centered above horizontal lines
  geom_text(data = subset(all.smoops.df, !is.na(p_value_Oops_vs_Control)),
            aes(label = paste0("p = ", format(p_value_Oops_vs_Control, digits = 2)),
                y = 0.705, x = 1.5),
            size = 3.5, vjust = -0.5,
            fontface = "italic", color = "black") +

  # Add p-values for Semi vs Control, centered above horizontal lines
  geom_text(data = subset(all.smoops.df, !is.na(p_value_Semi_vs_Control)),
            aes(label = paste0("p = ", format(p_value_Semi_vs_Control, digits = 2)),
                y = 0.755, x = 2),
            size = 3.5, vjust = -0.5,
            fontface = "italic", color = "black") +

  # Draw the horizontal lines only once
  geom_segment(data = subset(all.smoops.df, group == "control"),
               aes(x = 1, xend = 2, y = 0.7, yend = 0.7), linewidth = 0.4) +
  geom_segment(data = subset(all.smoops.df, group == "control"),
               aes(x = 1, xend = 3, y = 0.75, yend = 0.75), linewidth = 0.4) +
  scale_x_discrete(labels = c("control" = "control", "semi" = "Semi-extractibility", "oops" = "OOPS")) +
  ggtitle("naive smOOPs unique-mapping reads") +
  scale_fill_manual(values = smoops_values) +
    theme(
    strip.text = element_blank(),  # Remove facet labels
    strip.background = element_blank(),  # Remove facet boxes
    legend.title = element_blank(),  # Remove legend title
    axis.text.x = element_text(size = 9))

intron.gg <- plot_grid(summary.intronic.all.gg, summary.intronic.smoops.gg, ncol = 2)
```


