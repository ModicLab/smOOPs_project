---
title: "Analyses of mESCs transcriptome-wide datasets: OOPS, semi-extractibility assay and RNA-seq"
author: "Ira Iosub"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  html_notebook:
    toc: yes
    toc_depth: 3
    toc_float: yes
    theme: paper
    highlight: monochrome
    df_print: paged
    code_folding: hide
  html_document:
    toc: yes
    toc_depth: '3'
    df_print: paged
---

#### Libraries

```{r include=FALSE, warning=FALSE}
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(tidyverse, warn.conflicts = FALSE))
suppressPackageStartupMessages(library(data.table))
suppressPackageStartupMessages(library(DESeq2))
# suppressPackageStartupMessages(library(ggrepel))
suppressPackageStartupMessages(library(cowplot))
# suppressPackageStartupMessages(library(RColorBrewer))
# suppressPackageStartupMessages(library(org.Mm.eg.db))
# suppressPackageStartupMessages(library(clusterProfiler))
suppressPackageStartupMessages(library(UpSetR))
suppressPackageStartupMessages(library(GenomicFeatures))
suppressPackageStartupMessages(library(rtracklayer))
suppressPackageStartupMessages(library(circlize))
suppressPackageStartupMessages(library(ComplexHeatmap))
suppressPackageStartupMessages(library(corrplot))


theme_set(theme_cowplot() +
            theme(legend.position = "top"))
```

# Functions

```{r}
#' Plot smOOPs Scatter Plot
#'
#' This function generates a scatter plot comparing the log2 fold changes of semi-extractable RNA and OOPS RNA for a specific developmental stage. The function identifies and classifies smOOPs transcripts based on user-defined thresholds for adjusted p-value and log2 fold change. It also computes and displays the Pearson correlation between the semi-extractable and OOPS log2 fold changes.
#'
#' @param semi_stage.ashr A data frame containing differential expression results (including `padj` and `log2FoldChange`) from the semi-extractability assay for the selected stage.
#' @param oops_stage.ashr A data frame containing differential expression results (including `padj` and `log2FoldChange`) from the OOPS assay for the selected stage.
#' @param stage A character string indicating the developmental stage, used for labeling and classification (e.g., "naive", "epi", "diff").
#' @param max_padj A numeric value specifying the adjusted p-value threshold to classify transcripts as significant. Default is 0.01.
#' @param min_lfc A numeric value specifying the minimum log2 fold change threshold to classify transcripts as enriched. Default is 1.
#'
#' @return A list containing:
#'   \item{data}{The data frame used for plotting, including the classifications of smOOPs and non-smOOPs.}
#'   \item{plot}{The ggplot object visualizing the scatter plot with correlation annotation.}
#'
#' @details The function filters transcripts based on the specified `padj` and `log2FoldChange` thresholds from both the semi-extractability and OOPS assays. Transcripts meeting these criteria are classified as smOOPs for the given stage. The plot includes color-coded classifications, with dashed lines indicating the log2 fold change thresholds. The Pearson correlation coefficient is also displayed on the plot.
#'
#' @examples
#' # Example usage:
#' plot_smoops_scatter(semi_data, oops_data, "naive")
#'
plot_smoops_scatter <- function(semi_stage.ashr, oops_stage.ashr, stage, max_padj = 0.01, min_lfc = 1) {

  stage_lfc.df <- left_join(data.frame(semi_stage.ashr) %>%
                            rownames_to_column(var = "gene_id") %>%
                              dplyr::select(gene_id, padj, log2FoldChange) %>%
                            dplyr::filter(padj < max_padj & log2FoldChange > 0),
                            data.frame(oops_stage.ashr) %>%
                            rownames_to_column(var = "gene_id") %>%
                              dplyr::select(gene_id, padj, log2FoldChange) %>%
                            dplyr::filter(padj < max_padj & log2FoldChange > 0),
                            by = "gene_id", suffix = c("_semi", "_oops")) %>%
  dplyr::filter(!is.na(log2FoldChange_semi)) %>%
  dplyr::filter(!is.na(log2FoldChange_oops))

  # Create a new column to classify points
  stage_lfc.df$classification <- ifelse(
    stage_lfc.df$padj_semi < max_padj & stage_lfc.df$padj_oops < max_padj &
    abs(stage_lfc.df$log2FoldChange_semi) > min_lfc & abs(stage_lfc.df$log2FoldChange_oops) > min_lfc,
    paste0(stage," smOOPs"), "non-smOOPs"
  )


  # Get the number of smOOPs
  stage_smoops_counts = nrow(stage_lfc.df %>% dplyr::filter(classification == paste0(stage," smOOPs")))

  # Add the count


  # Plot
  stage.base_plot.gg <- ggplot(stage_lfc.df, aes(x = log2FoldChange_semi, y = log2FoldChange_oops, color = classification)) +
    geom_point(alpha = 0.2, stroke = 1) +
    geom_hline(yintercept = 1, linetype = "dashed", color = "black") +
    geom_vline(xintercept = 1, linetype = "dashed", color = "black") +
    # geom_text_repel(data = subset(stage_lfc.df, log2FoldChange_semi > 4.5 | log2FoldChange_oops > 4.5),
    #                 aes(label = gene_id), size = 2.5, max.overlaps = 10) +
    labs(# title = "Naive smOOPS LFC Correlation",
         x = "Log2 Fold Change (Semi-extractibility vs Control)",
         y = "Log2 Fold Change (OOPS vs Control)") +
    theme_cowplot() +
    # ggtitle("naive lfc corr") +
    # stat_cor(method = "pearson", label.x = 0.1, label.y = 5, size = 4) +
    # scale_color_manual(values = c("naive smOOPs" = "#4682B4", "nonsmOOPS" = "grey30"), name = NULL)
    scale_color_manual(values = c("naive smOOPs" = "#4682B4",
                                  "epi smOOPs" = "#008080",
                                  "diff smOOPs" = "#894c89",
                                  "nonsmOOPs" = "grey30"),
                       labels = paste0(stage," smOOPs (n = ", stage_smoops_counts, ")")) +
    theme(axis.text.x = element_text(angle = 0, hjust = 1),
        legend.title = element_blank())
    # stat_cor(method = "pearson", label.x = 0.1, label.y = 5, size = 3, aes(group = 1)) # Add Pearson correlation coefficient

  # Add Pearson correlation coefficient separately
  cor_result <- cor.test(stage_lfc.df$log2FoldChange_semi, stage_lfc.df$log2FoldChange_oops)
  cor_label <- paste("R =", round(cor_result$estimate, 2), ", p <", format(cor_result$p.value, digits = 2, scientific = TRUE))

  # Combine the base plot and the correlation label
  stage.final_plot.gg <- stage.base_plot.gg +
    annotate("text", x = 0.1, y = 5, label = cor_label, size = 3, hjust = 0) +
    guides(color = guide_legend(override.aes = list(size = 3)))

  return(list(data = stage.final_plot.gg, plot = stage.final_plot.gg))

}


#' Create or load a transcript database (TxDb) from a GTF file.
#'
#' This function creates a transcript database (TxDb) from a given GTF file if it doesn't already exist, 
#' or loads it from a previously saved SQLite database file if available. The resulting TxDb object is 
#' then restricted to standard chromosomes.
#'
#' @param gtf A character string representing the file path to the GTF file.
#' @param org A character string specifying the organism name (used when creating the TxDb).
#' @return A TxDb object representing the transcript database.
#'
#' @details 
#' - If the SQLite database file (`.sqlite`) already exists for the given GTF file, it will be loaded to avoid re-creating it.
#' - If the SQLite database does not exist, it is generated using `makeTxDbFromGFF()`, saved to a `.sqlite` file, and then loaded.
#' - The resulting TxDb object is pruned to keep only the standard chromosomes.
#'
#' @examples
#' # Create or load a TxDb object from a GTF file:
#' txdb <- make_txdb("path/to/your_file.gtf", "Homo sapiens")
#'
make_txdb <- function(gtf, org) {

  # Get name of db
  name <- paste0(str_split(gtf, ".gtf")[[1]][1], ".sqlite")

  if (file.exists(name)) {

    TxDb <- loadDb(name)

  } else {

    TxDb <- makeTxDbFromGFF(gtf, format="gtf",
                            organism = org)

    saveDb(TxDb, file=name)
  }

  TxDb <- keepStandardChromosomes(TxDb, pruning.mode="coarse")
  return(TxDb)
}


#' Annotate a data frame with gene information.
#'
#' This function annotates a given data frame by adding gene information (gene name and gene type) based on a GRanges object containing gene annotations. The gene information is joined to the data frame using the `gene_id` column.
#'
#' @param annotation.gr A GRanges object containing genomic annotations, including gene IDs, names, and types. Only annotations of type "gene" are used.
#' @param df A data frame to be annotated, which should contain a `gene_id` column. If it doesn't, the rownames are assumed to be gene IDs and are converted into a `gene_id` column.
#' @return A data frame with the original columns from `df` and additional columns for `gene_name` and `gene_type`.
#'
#' @details
#' - The function filters the `annotation.gr` object to only include entries of type "gene".
#' - If the input `df` does not contain a `gene_id` column, the rownames are converted to `gene_id`.
#' - The gene annotations are then joined to the data frame based on `gene_id` using a left join.
#'
#' @examples
#' # Example usage
#' annotated_df <- annotate_genes(annotation.gr, expression_df)
#'
annotate_genes <- function(annotation.gr, df) {
  
  annotation.genes.df <- as.data.frame(annotation.gr[annotation.gr$type == "gene"]) %>% 
    dplyr::select(gene_id, gene_name, gene_type)
  
  if (! "gene_id" %in% colnames(df)) {
    
    df <- rownames_to_column(df, "gene_id")
    
  }
  
  annotated.df <- left_join(df, annotation.genes.df, by = "gene_id")
  
  return(annotated.df)
}


#' Plot a stacked bar chart with percentages.
#'
#' This function creates a stacked bar chart where the height of each bar represents percentages. The bars are grouped by a specified column and colored according to a categorical column. The chart includes options for simplifying the categories by merging low-frequency categories into an "Other" group.
#'
#' @param data.df A data frame containing the data to be plotted.
#' @param column The column containing the categorical variable to be displayed in the stacked bar chart.
#' @param group The grouping variable (e.g., conditions or categories for x-axis).
#' @param simplify Logical, whether to simplify low-percentage categories into an "Other" category (default is TRUE).
#' @return A list containing:
#'   - `plot`: The ggplot object representing the stacked bar chart.
#'   - `data`: A data frame of the summarized data used for the plot.
#'
#' @details
#' - The function calculates the percentage of each category within each group.
#' - When `simplify = TRUE`, categories representing less than 1% of the total are grouped into an "Other" category.
#' - The function also adds labels to the plot indicating the percentage of each segment.
#'
#' @examples
#' # Example usage:
#' # Assuming `my_data` is a data frame with columns "gene_id", "condition", and "category"
#' result <- plot_stacked_barchart(my_data, column = category, group = condition, simplify = TRUE)
#' result$plot  # To display the plot
#'
plot_stacked_barchart <- function(data.df, column, group=NULL, simplify=TRUE) {

  if (!("id" %in% colnames(data.df))) {
    data.df$id <- data.df$gene_id

  } else {
    #next
    data.df$id <- data.df$id
  }

  data_counts.df <- data.df %>%
    dplyr::select(id, {{group}}, {{column}}) %>%
    distinct() %>%
    group_by({{group}}, {{column}}) %>%
    summarise(counts = n()) %>%
    arrange(desc({{column}})) %>%
    mutate(percentage = scales::percent(counts / sum(counts), accuracy = 0.01)) %>%
    mutate(percentage = as.numeric(sub("%","", percentage))) %>%
    ungroup() %>%
    group_by({{group}}) %>%
    #mutate(percentage = counts*100 / sum(counts)) %>%
    mutate(pos = cumsum(percentage) - percentage/2)


  if (simplify) {
    data_counts.df <- data_counts.df %>%
      mutate(category = case_when((percentage <= 1) ~ "Other",
                                  (percentage > 1) ~ {{column}}))

    data_counts.df <- data_counts.df %>%
      group_by({{group}}, category) %>%
      mutate(percentage = sum(percentage)) %>%
      ungroup() %>%
      dplyr::select(category, percentage, {{group}}) %>%
      distinct() %>%
      arrange(desc(category)) %>%
      group_by({{group}}) %>%
      mutate(pos = cumsum(percentage) - percentage/2) 

  } else {

    data_counts.df <- data_counts.df %>%
      mutate(category = {{column}})
  }

  bar = ggplot() +
    geom_bar(aes(y = percentage, x = {{group}}, fill = category), data = data_counts.df,
             stat="identity", width = 0.5) +  # color="black"
    ggrepel::geom_text_repel(data = data_counts.df, aes(x = {{group}}, y = pos, label=paste0(round(percentage, 1),"%")), size = 3, nudge_x = 0.4,
                             segment.size = 0.5, segment.color = '#515A5A') + # label=paste0(round(percentage, 2),"%"))
    #facet_grid(cols = vars({{group}})) +
    paletteer::scale_fill_paletteer_d("rcartocolor::Earth", direction = -1) +
    # scale_fill_manual(values = "#5b859e","#1e395f","#75884b","#1e5a46","#df8d71","#af4f2f","#d48f90","#732f30","#ab84a5","#59385c","#d8b847","#b38711") + #metbrewer Redon
    theme(legend.position="bottom", legend.direction="horizontal",
          legend.title = element_blank()) +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
    ylab("Percentage") + xlab("") +
    theme_cowplot()

  # return(bar)
  return(list(plot = bar, data = data_counts.df))
}


#' Plot a heatmap of z-scores with column splits specific to the smOOPs project
#'
#' This function generates a heatmap of z-scores for a given data frame, with columns split into groups (control, semi, and OOPS). The heatmap includes row names and options for clustering rows and columns.
#'
#' @param df A data frame where rows are genes and columns are z-scores for different conditions.
#' @param title A character string specifying the title of the heatmap.
#' @return A Heatmap object representing the z-score heatmap with column splits.
#'
#' @details
#' - The columns are split by the groups "control", "semi", and "OOPS".
#' - Row clustering is enabled by default, while column clustering is disabled.
#' - Gene names (row names) are displayed on the left side of the heatmap.
#' - Column names (conditions) are displayed at the top of the heatmap.
#'
#' @examples
#' # Example usage:
#' heatmap <- plot_zscore_heatmap(df, title = "Z-score Heatmap")
#' draw(heatmap)
#'
plot_zscore_heatmap <- function(df, title) {
  
  # Prepare the data matrix
  data_matrix <- as.matrix(df)
  
  # Create the heatmap with column and row splits
  h <- Heatmap(
    data_matrix, 
    name = "zscore", 
    column_split = factor(rep(c("control", "semi", "OOPS"), each = 1), levels = c("control", "semi", "OOPS")),  # Column split by groups
    cluster_rows = T,  # Disable row clustering
    cluster_columns = FALSE, 
    column_title = title,   # Disable column clustering
    show_row_names = TRUE,  # Show gene names (gene_id)
    row_names_side = "left",
    show_column_names = T,  # Show column names
    #heatmap_legend_param = list(title = "zscore", title_position = "top")
    )
  return(h)
}
```


# OOPS and semi-extractibility data

Contains analyses of RNA-seq data from a semi-extractibility assay and OOPS experiments performed by Tajda (Ule lab).
Done in triplicates and three conditions: 

*	Naïve mESC (Naïve)
*	primed puripotency (EpiSC)
*	1 day upon exit of pluripotency (Diff/T)

* Normal = normal trizol extraction
* Semi = semi-extractibility assay data (heating and shearing before trizol extraction to obtain semi-extractable RNAs)
* OOPS = OOPS


Set paths and color scheme for results

```{r}
base.results.dir <- "~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/"
figures.dir <- paste0(base.results.dir, "figures/")

# smoops_colors = c("naive" = "#4682B4", "epi" = "#008080", diff = "#894c89")
# control_colors = c("naive" = "#4682B433", "epi" = "#00808033", diff = "#894C8933")

smoops_values = c("naive" = "#4682B4", "epi" = "#008080", diff = "#894c89")
control_values = c("naive" = "#bdcae2", "epi" = "#b1c7c9", diff = "#cdb7d1")
```


The starting point for the analyses were **STAR-salmon** raw count output from analyses ran using nf-core rnaseq v3.4 pipeline

```{r}
# DGE
data.df <- fread(paste0(base.results.dir, "deseq2_smoops/salmon_count_tables/salmon.merged.gene_counts_length_scaled.tsv"))

# Create metadata
data.df <- data.df %>%
  remove_rownames %>%
  column_to_rownames(var = "gene_id") %>%
  dplyr::select(-gene_name)

sample.ls <- colnames(data.df)
condition.ls <- unlist(lapply(sample.ls, function(x) str_split(x, "_")[[1]][1]))
stage.ls <- unlist(lapply(sample.ls, function(x) str_split(x, "_")[[1]][2]))

meta.df <- data.table(sample = sample.ls, condition = condition.ls, stage = stage.ls) %>%
  group_by(condition) %>%
  dplyr::arrange(desc(stage)) %>%
  dplyr::arrange(condition) %>%
  remove_rownames %>%
  column_to_rownames(var = "sample")

data.df <- dplyr::select(data.df, row.names(meta.df))
stopifnot(colnames(data.df) == rownames(meta.df))

meta.df$condition <- as.factor(meta.df$condition)
meta.df$stage <- as.factor(meta.df$stage)
```

# DESeq2 to obtain smOOPs using combined groups

Set thresholds for effect size and significance:

```{r}
min_lfc <- 1
max_padj <- 0.01
```


```{r}
# Ensure correct reference levels
meta.df$stage <- relevel(meta.df$stage, ref = "naive")
meta.df$condition <- relevel(meta.df$condition, ref = "control")

# Combine factors into a single group
meta.df$group <- factor(paste0(meta.df$condition, "_", meta.df$stage))

# Create the DESeqDataSet with the group factor
dds <- DESeqDataSetFromMatrix(countData = round(data.df), colData = meta.df,
                              design = ~ group)

# Filter so we keep genes with min 10 counts in at least 6 samples
dds <- estimateSizeFactors(dds)
idx <- rowSums(counts(dds, normalized = TRUE) >= 10) >= 6
dds <- dds[idx,]

# Run DESeq2
dds <- DESeq(dds)

# List available results names to confirm that the desired contrast is included
resultsNames(dds)
```

## DESeq2 results for smOOPs

```{r}
# naive 
res_semi_naive_vs_control_naive <- results(dds, contrast = c("group", "semi_naive", "control_naive"))
res_oops_naive_vs_control_naive <- results(dds, contrast = c("group", "oops_naive", "control_naive"))
# epi
res_semi_epi_vs_control_epi <- results(dds, contrast = c("group", "semi_epiSC", "control_epiSC"))
res_oops_epi_vs_control_epi <- results(dds, contrast = c("group", "oops_epiSC", "control_epiSC"))
# diff
res_semi_diff_vs_control_diff <- results(dds, contrast = c("group", "semi_diff", "control_diff"))
res_oops_diff_vs_control_diff <- results(dds, contrast = c("group", "oops_diff", "control_diff"))
```

LFC shrinkage

```{r warning=FALSE}
# naive
semi_naive.ashr <- lfcShrink(dds, type="ashr",contrast = c("group", "semi_naive", "control_naive"),
                        res = res_semi_naive_vs_control_naive)

oops_naive.ashr <- lfcShrink(dds, type="ashr",contrast = c("group", "oops_naive", "control_naive"),
                        res = res_oops_naive_vs_control_naive)

# epi
semi_epi.ashr <- lfcShrink(dds, type="ashr",contrast = c("group", "semi_epi", "control_epi"),
                        res = res_semi_epi_vs_control_epi)

oops_epi.ashr <- lfcShrink(dds, type="ashr",contrast = c("group", "oops_epi", "control_epi"),
                        res = res_oops_epi_vs_control_epi)


# diff
semi_diff.ashr <- lfcShrink(dds, type="ashr",contrast = c("group", "semi_diff", "control_diff"),
                        res = res_semi_diff_vs_control_diff)

oops_diff.ashr <- lfcShrink(dds, type="ashr",contrast = c("group", "oops_diff", "control_diff"),
                        res = res_oops_diff_vs_control_diff)
```

Get significant genes semi vs control and oops vs control

```{r}
# naive
sig_res_semi_naive_vs_control_naive.df <- data.frame(semi_naive.ashr) %>%
  dplyr::filter(padj < max_padj & log2FoldChange > min_lfc) %>% rownames_to_column(var = "gene_id")

sig_res_oops_naive_vs_control_naive.df <- data.frame(oops_naive.ashr) %>%
  dplyr::filter(padj < max_padj & log2FoldChange > min_lfc) %>% rownames_to_column(var = "gene_id")

# epi
sig_res_semi_epi_vs_control_epi.df <- data.frame(semi_epi.ashr) %>%
  dplyr::filter(padj < max_padj & log2FoldChange > min_lfc) %>% rownames_to_column(var = "gene_id")

sig_res_oops_epi_vs_control_epi.df <- data.frame(oops_epi.ashr) %>%
  dplyr::filter(padj < max_padj & log2FoldChange > min_lfc) %>% rownames_to_column(var = "gene_id")

# diff
sig_res_semi_diff_vs_control_diff.df <- data.frame(semi_diff.ashr) %>%
  dplyr::filter(padj < max_padj & log2FoldChange > min_lfc) %>% rownames_to_column(var = "gene_id")

sig_res_oops_diff_vs_control_diff.df <- data.frame(oops_diff.ashr) %>%
  dplyr::filter(padj < max_padj & log2FoldChange > min_lfc) %>% rownames_to_column(var = "gene_id")

```


Save files:

```{r}
# fwrite(data.frame(semi_naive.ashr) %>% rownames_to_column(var = "gene_id"), paste0(base.results.dir, "deseq2_smoops/deseq2_results_tables/semi_naive_vs_control_naive_deseq.tsv"), sep = "\t", row.names = F)
# fwrite(data.frame(oops_naive.ashr) %>% rownames_to_column(var = "gene_id"), paste0(base.results.dir, "deseq2_smoops/deseq2_results_tables/oops_naive_vs_control_naive_deseq.tsv"), sep = "\t", row.names = F)

# fwrite(data.frame(semi_epi.ashr) %>% rownames_to_column(var = "gene_id"), paste0(base.results.dir, "deseq2_smoops/deseq2_results_tables/semi_epi_vs_control_epi_deseq.tsv"), sep = "\t", row.names = F)
# fwrite(data.frame(oops_epi.ashr) %>% rownames_to_column(var = "gene_id"), paste0(base.results.dir, "deseq2_smoops/deseq2_results_tables/oops_epi_vs_control_epi_deseq.tsv"), sep = "\t", row.names = F)

# fwrite(data.frame(semi_diff.ashr) %>% rownames_to_column(var = "gene_id"), paste0(base.results.dir, "deseq2_smoops/deseq2_results_tables/semi_diff_vs_control_diff_deseq.tsv"), sep = "\t", row.names = F)
# fwrite(data.frame(oops_diff.ashr) %>% rownames_to_column(var = "gene_id"), paste0(base.results.dir, "deseq2_smoops/deseq2_results_tables/oops_diff_vs_control_diff_deseq.tsv"), sep = "\t", row.names = F)

```


## Get smOOPs

```{r}
# naive
naive.smoops.ls <- intersect(sig_res_semi_naive_vs_control_naive.df$gene_id, sig_res_oops_naive_vs_control_naive.df$gene_id)
naive_smoops.df <- left_join(sig_res_semi_naive_vs_control_naive.df %>%
                              dplyr::filter(gene_id %in% naive.smoops.ls) %>%
                              dplyr::select(gene_id, padj, log2FoldChange),
                            sig_res_oops_naive_vs_control_naive.df %>%
                              dplyr::filter(gene_id %in% naive.smoops.ls) %>%
                              dplyr::select(gene_id, padj, log2FoldChange),
                            by = "gene_id", suffix = c("_semi", "_oops"))

# epi
epi.smoops.ls <- intersect(sig_res_semi_epi_vs_control_epi.df$gene_id, sig_res_oops_epi_vs_control_epi.df$gene_id)
epi_smoops.df <- left_join(sig_res_semi_epi_vs_control_epi.df %>%
                              dplyr::filter(gene_id %in% epi.smoops.ls) %>%
                              dplyr::select(gene_id, padj, log2FoldChange),
                            sig_res_oops_epi_vs_control_epi.df %>%
                              dplyr::filter(gene_id %in% epi.smoops.ls) %>%
                              dplyr::select(gene_id, padj, log2FoldChange),
                            by = "gene_id", suffix = c("_semi", "_oops"))

# diff
diff.smoops.ls <- intersect(sig_res_semi_diff_vs_control_diff.df$gene_id, sig_res_oops_diff_vs_control_diff.df$gene_id)
diff_smoops.df <- left_join(sig_res_semi_diff_vs_control_diff.df %>%
                              dplyr::filter(gene_id %in% diff.smoops.ls) %>%
                              dplyr::select(gene_id, padj, log2FoldChange),
                            sig_res_oops_diff_vs_control_diff.df %>%
                              dplyr::filter(gene_id %in% diff.smoops.ls) %>%
                              dplyr::select(gene_id, padj, log2FoldChange),
                            by = "gene_id", suffix = c("_semi", "_oops"))
```

Save files:

```{r}
# fwrite(data.frame(naive_smoops.df), paste0(base.results.dir, "deseq2_smoops/deseq2_results_tables/naive_smoops_deseq.tsv"), sep = "\t", row.names = F)
# fwrite(data.frame(epi_smoops.df), paste0(base.results.dir, "deseq2_smoops/deseq2_results_tables/epi_smoops_deseq.tsv"), sep = "\t", row.names = F)
# fwrite(data.frame(diff_smoops.df), paste0(base.results.dir, "deseq2_smoops/deseq2_results_tables/diff_smoops_deseq.tsv"), sep = "\t", row.names = F)
```

## Plot smOOPs overlaps

### Upset plot

```{r}
# Combine the smOOPs sets into a list
sig_gene_lists <- list(
  naive = naive.smoops.ls,
  epi = epi.smoops.ls,
  diff = diff.smoops.ls
)

# Convert the list of significant genes into a binary matrix
all_genes <- unique(unlist(sig_gene_lists))
binary_matrix <- sapply(sig_gene_lists, function(x) as.integer(all_genes %in% x))
rownames(binary_matrix) <- all_genes


# Create the UpSet plot
pdf(paste0(figures.dir, "figure_1/smoops_upset.pdf"))
upset(as.data.frame(binary_matrix),
      sets = c("naive", "epi", "diff"),
      order.by = "freq",
      empty.intersections = "on", 
      mainbar.y.label = "Genes Intersection Size",
      sets.x.label = "smOOPS Per Stage",
      sets.bar.color = rev(smoops_values))
dev.off()
```

### LFC scatter plots

```{r}
naive_scatter <- plot_smoops_scatter(semi_naive.ashr, oops_naive.ashr, stage = "naive", max_padj, min_lfc)
epi_scatter <- plot_smoops_scatter(semi_epi.ashr, oops_epi.ashr, stage = "epi", max_padj, min_lfc)
diff_scatter <- plot_smoops_scatter(semi_diff.ashr, oops_diff.ashr, stage = "diff", max_padj, min_lfc)

corr.gg <- cowplot::plot_grid(naive_scatter$plot, epi_scatter$plot, diff_scatter$plot,
                   ncol = 1)

# ggsave(paste0(figures.dir, "figure_1/smoops_lfc_correlation.pdf"), corr.gg, dpi = 300, height = 16, width = 7)
```


# Basic features of smOOPs (compared to controls)

Load mastertable to extract transcripts

```{r}
master.df <- fread("~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/Master Dataset/all_smOOPS_and_controls_V2.tsv")
```

Extract feature lengths

```{r}
mm.txdb <- make_txdb(paste0(base.results.dir, "ref/gencode.vM27.annotation.gtf.gz"), "Mus musculus")
txlengths <- transcriptLengths(mm.txdb, with.cds_len = TRUE,
                               with.utr5_len = TRUE,
                               with.utr3_len = TRUE)

txlengths.dt <- data.table(txlengths, key = c("tx_name", "gene_id"))
```


Add feature lengths to mastertable

```{r}
master.df <- left_join(master.df, txlengths.dt, by = c("transcript_id" = "tx_name", "gene_id")) %>% dplyr::select(-tx_id, -nexon)

naive.tx_features.df <- master.df %>%
  dplyr::filter(smoops_naive == TRUE) %>%
  dplyr::select(-(smoops_naive:control_common)) %>%
  mutate(group = "naive smOOPs")

epi.tx_features.df <- master.df %>%
  dplyr::filter(smoops_epi == TRUE) %>%
  dplyr::select(-(smoops_naive:control_common)) %>%
  mutate(group = "epi smOOPs")

diff.tx_features.df <- master.df %>%
  dplyr::filter(smoops_diff == TRUE) %>%
  dplyr::select(-(smoops_naive:control_common)) %>%
  mutate(group = "diff smOOPs")

control.tx_features.df <- master.df %>%
  dplyr::filter(control_common == TRUE) %>%
  dplyr::select(-(smoops_naive:control_common)) %>%
  mutate(group = "control")

all.tx_features.df <- rbind(naive.tx_features.df, epi.tx_features.df, diff.tx_features.df, control.tx_features.df)
```

Pivot longer and rename features for plotting

```{r}
all.tx_features.long.df <- pivot_longer(all.tx_features.df, cols = c(tx_len, utr5_len, cds_len, utr3_len), names_to = "feature_type", values_to = "length")

all.tx_features.long.df <- all.tx_features.long.df %>%
  mutate(feature_type = case_when(feature_type == "tx_len" ~ "transcript",
                                  feature_type == "utr5_len" ~ "5'UTR",
                                  feature_type == "utr3_len" ~ "3'UTR",
                                  feature_type == "cds_len" ~ "CDS"))

all.tx_features.long.df$feature_type <- factor(all.tx_features.long.df$feature_type, levels = c("transcript", "5'UTR", "CDS", "3'UTR"))
all.tx_features.long.df$group <- factor(all.tx_features.long.df$group, levels = c("control", "naive smOOPs", "epi smOOPs", "diff smOOPs"))

# Plot
features.gg <- ggplot(all.tx_features.long.df %>% dplyr::filter(length >= 1), aes(x = group, y = length)) +
  geom_violin(aes(fill = group, colour = group)) +
  geom_boxplot(width = 0.15, alpha = 0.5) +
  scale_color_manual(values = c("naive smOOPs" = "#4682B4",
                                  "epi smOOPs" = "#008080",
                                  "diff smOOPs" = "#894c89",
                                  "control" = "grey70")) +
  scale_fill_manual(values = c("naive smOOPs" = "#4682B4",
                                  "epi smOOPs" = "#008080",
                                  "diff smOOPs" = "#894c89",
                                  "control" = "grey70")) +
  #scale_color_manual(values = c(smoops_colors, "control" = "grey70")) +
  #scale_fill_manual(values = c(smoops_colors, "control" = "grey70")) +
  scale_y_log10() +
  # annotation_logticks(sides = "l") +
  theme(axis.text.x = element_text(angle = 60, hjust = 1), axis.title.x = element_blank(),
        legend.title = element_blank()) +
  facet_grid(~feature_type, space = "free")

# ggsave(paste0(figures.dir, "figure_1/smoops_feature_lengths.pdf"), features.gg, dpi = 300, width = 8, height = 8)
# ggsave(paste0(figures.dir, "figure_1/smoops_feature_lengths.png"), features.gg, dpi = 300, width = 8, height = 8)
```


# Annotation of smOOPs

Load annotation

```{r}
mm.gr <- rtracklayer::import.gff2(paste0(base.results.dir, "ref/gencode.vM27.annotation.gtf.gz"))
```

Annotate smOOPs

```{r}
naive_smoops.df <- annotate_genes(mm.gr, naive_smoops.df) %>%
  dplyr::mutate(group = "naive smOOPs")

epi_smoops.df <- annotate_genes(mm.gr, epi_smoops.df) %>%
  dplyr::mutate(group = "epi smOOPs")

diff_smoops.df <- annotate_genes(mm.gr, diff_smoops.df) %>%
  dplyr::mutate(group = "diff smOOPs")

all_smoops.df <- rbind(naive_smoops.df, epi_smoops.df, diff_smoops.df) %>%
  dplyr::select(gene_id, gene_type, group)
```

Annotate non-smOOPs

```{r}
deseq_input_genes.df <- data.frame(semi_naive.ashr) %>%
  rownames_to_column(var = "gene_id") %>%
  mutate(group = "non-smOOPs") %>%
  dplyr::select(gene_id, group)

deseq_input_genes.df <- annotate_genes(mm.gr, deseq_input_genes.df) %>%
  dplyr::select(gene_id, gene_type, group)

# Remove smOOPs then combine all for plotting
deseq_input_genes.df <- anti_join(deseq_input_genes.df, all_smoops.df, by = "gene_id")
annotated_groups.df <- rbind(all_smoops.df, deseq_input_genes.df)

# annotated_groups.counts.df <- annotated_groups.df %>%
#   group_by(group, gene_type) %>%
#   summarise(counts = n())

# Get percentages
per.df <- plot_stacked_barchart(annotated_groups.df, column = gene_type, group = group)$data

per.df$category <- factor(per.df$category, levels = c("lncRNA", "protein_coding", "TEC", "processed_pseudogene", "Other"))
per.df$group <- factor(per.df$group, levels = c("non-smOOPs","naive smOOPs", "epi smOOPs", "diff smOOPs"))

# Plot
bar1.gg <- ggplot(per.df, aes(x = category, y = percentage)) +
  geom_bar(stat = "identity", width = 0.5, position = "dodge", aes(fill = group)) +
  facet_grid(rows = vars(group)) +
  scale_color_manual(values = c("naive smOOPs" = "#4682B4",
                                  "epi smOOPs" = "#008080",
                                  "diff smOOPs" = "#894c89",
                                  "non-smOOPs" = "grey70")) +
  scale_fill_manual(values = c("naive smOOPs" = "#4682B4",
                                  "epi smOOPs" = "#008080",
                                  "diff smOOPs" = "#894c89",
                                  "non-smOOPs" = "grey70")) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1), axis.title.x = element_blank(),
        legend.title = element_blank(),
        strip.text = element_blank(),       # Remove facet labels
        strip.background = element_blank()) # Remove facet boxes
```


```{r}
bar2.gg <- ggplot(per.df, aes(x = category, y = percentage, fill = group)) +
  geom_bar(stat = "identity", width = 0.5, position = position_dodge(width = 0.55)) +
  ylab("Proportion") + xlab("") +
  # scale_color_manual(values = c("naive smOOPs" = "#4682B4",
  #                                 "epi smOOPs" = "#008080",
  #                                 "diff smOOPs" = "#894c89",
  #                                 "non-smOOPs" = "grey70")) +
  scale_fill_manual(values = c("naive smOOPs" = "#4682B4",
                                  "epi smOOPs" = "#008080",
                                  "diff smOOPs" = "#894c89",
                                  "non-smOOPs" = "grey70")) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1), axis.title.x = element_blank(),
        legend.title = element_blank())

# ggsave(paste0(figures.dir, "figure_1/smoops_gene_types_facets.pdf"), bar1.gg, dpi = 300, width = 6, height = 18)
# ggsave(paste0(figures.dir, "figure_1/smoops_gene_types_facets.png"), bar1.gg, dpi = 300, width = 6, height = 18)
# 
# ggsave(paste0(figures.dir, "figure_1/smoops_gene_types_grouped.pdf"), bar2.gg, dpi = 300, width = 8, height = 8)
# ggsave(paste0(figures.dir, "figure_1/smoops_gene_types_grouped.png"), bar2.gg, dpi = 300, width = 8, height = 8)
```


```{r}
# plot_stacked_barchart(annotated_groups.df, column = gene_type, group = group) 
```

# PCA and pairwise count correlations

## PCA

```{r}
rlog <- rlog(dds)

# Assuming the 'assay' column exists in your data, modify the plot accordingly:
pca_data$condition <- colData(rlog)$condition  # Make sure 'assay' is part of your data

# Create the PCA plot with shape based on assay type
pca.gg <- ggplot(pca_data, aes(PC1, PC2, color = stage)) +
  geom_point(size = 4, alpha = 0.8, aes(shape = condition)) +  # Adjust point size and transparency
  # geom_text_repel(aes(label = sample), 
  #                 box.padding = 0.7, 
  #                 point.padding = 0.5, 
  #                 max.overlaps = Inf, 
  #                 size = 5,  # Increase label size
  #                 segment.color = 'black', # Segment line from label to point
  #                 segment.size = 0.4) +
  theme_cowplot() +
  theme(legend.position = "right",  # Adjust legend position
        legend.text = element_text(size = 12),  # Increase legend text size
        legend.title = element_text(size = 14),  # Increase legend title size
        axis.title = element_text(size = 14),  # Increase axis title size
        axis.text = element_text(size = 12)) +  # Increase axis text size
  scale_color_manual(values = c(naive = "#bdcae2", epiSC = "#b1c7c9", diff = "#cdb7d1")) +
  scale_shape_manual(values = c(16, 17, 18)) +  # Define different shapes for 'control', 'oops', 'semi'
  labs(shape = "Assay", color = "Stage")  # Rename the shape legend to 'Assay'

ggsave("~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/figures/figure_1/semi_oops_ctrl_pca.pdf",
       pca.gg, width = 7, height = 6, dpi = 300)
```



## correlation

Get rlog normalised counts

```{r}
rlog.df <- as.data.frame(assay(rlog))

# Calculate the Pearson correlation matrix
cor_matrix <- cor(rlog.df, method = "pearson")
custom_col <- colorRampPalette(c("white", "grey60", "grey30"))

# Create a correlation plot
corr.gg <- corrplot::corrplot(cor_matrix, method = "circle", 
         # addCoef.col = "white",              # Add correlation coefficients in black
         tl.col = "black",                   # Text label color
         is.corr = F,                     # Plot correlation matrix
         cl.pos = "r",                       # Position of color legend
         number.cex = 0.8,
         #col.lim = c(0.98, 1), # Size of the correlation labels
         tl.srt = 45,                        # Rotate text labels
         # number.digits = 3,
          col = custom_col(200))  # Use custom color gradient)                  # Show 3 decimal places for correlation values
```


# Plot top semi and OOPS-enriched genes from each stage

```{r}
# select top 5 semi in naive stc for semi or oops

top_semi_naive.df <- naive_smoops.df %>%
  slice_max(log2FoldChange_semi, n = 5)

top_oops_naive.df <- naive_smoops.df %>%
  slice_max(log2FoldChange_oops, n = 5)

top_semi_epi.df <- epi_smoops.df %>%
  slice_max(log2FoldChange_semi, n = 5)

top_oops_epi.df <- epi_smoops.df %>%
  slice_max(log2FoldChange_oops, n = 5)

top_semi_diff.df <- diff_smoops.df %>%
  slice_max(log2FoldChange_semi, n = 5)

top_oops_diff.df <- diff_smoops.df %>%
  slice_max(log2FoldChange_oops, n = 5)
```


```{r}
mean_rlog.df <- rlog.df %>%
  rownames_to_column(var = "id") %>%
  rowwise() %>%
  mutate(mean_semi_naive = mean(c_across(semi_naive_1:semi_naive_3), na.rm = TRUE),
         mean_semi_epi = mean(c_across(semi_epiSC_1:semi_epiSC_3), na.rm = TRUE),
         mean_semi_diff = mean(c_across(semi_diff_1:semi_diff_3), na.rm = TRUE),
         mean_control_naive = mean(c_across(control_naive_1:control_naive_3), na.rm = TRUE),
         mean_control_epi = mean(c_across(control_epiSC_1:control_epiSC_3), na.rm = TRUE),
         mean_control_diff = mean(c_across(control_diff_1:control_diff_3), na.rm = TRUE),
         mean_oops_naive = mean(c_across(oops_naive_1:oops_naive_3), na.rm = TRUE),
         mean_oops_epi = mean(c_across(oops_epiSC_1:oops_epiSC_3), na.rm = TRUE),
         mean_oops_diff = mean(c_across(oops_diff_1:oops_diff_2), na.rm = TRUE)) %>%
  ungroup() %>%
  dplyr::select(id, mean_control_naive, mean_semi_naive, mean_oops_naive, 
                mean_control_epi, mean_semi_epi, mean_oops_epi,
                mean_control_diff, mean_semi_diff, mean_oops_diff)
```

## rlog all-together

```{r}
top.mean_rlog.df <- mean_rlog.df %>%
  mutate(category = case_when(id %in% top_semi_naive.df$gene_id ~ "top_semi_naive",
                              id %in% top_oops_naive.df$gene_id ~ "top_oops_naive",
                              id %in% top_semi_epi.df$gene_id ~ "top_semi_epi",
                              id %in% top_oops_epi.df$gene_id ~ "top_oops_epi",
                              id %in% top_semi_diff.df$gene_id ~ "top_semi_diff",
                              id %in% top_oops_diff.df$gene_id ~ "top_oops_diff")) %>%
  dplyr::filter(!is.na(category))
```


```{r}
# Extract the relevant columns for the heatmap (excluding the 'category' column)
heatmap_data <- as.matrix(top.mean_rlog.df %>% 
                            dplyr::select(mean_control_naive, mean_semi_naive, mean_oops_naive, mean_control_epi, mean_semi_epi, mean_oops_epi,
                mean_control_diff, mean_semi_diff, mean_oops_diff))
rownames(heatmap_data) <- top.mean_rlog.df$id

# Optional: Define color scheme
col_fun <- colorRamp2(c(min(heatmap_data), mean(heatmap_data), max(heatmap_data)), 
                      c("blue", "white", "red"))

# Generate the heatmap
Heatmap(
  heatmap_data,
  name = "Expression",                         # Name for the legend
  col = col_fun,   
  column_split = factor(rep(c("Naive", "EpiSC", "diff"), each = 3), levels = c("Naive", "EpiSC", "diff")),  # Column split by groups
  show_row_names = TRUE,                       # Show gene IDs
  show_column_names = F,                    # Show condition names
  cluster_rows = T,                         # Cluster rows (genes)
  cluster_columns = F,                      # Cluster columns (conditions)
  column_title = "",                 # Title for the columns
  row_title = "Gene",                         # Title for the rows
  row_names_side = "left",
  heatmap_legend_param = list(title = "Normalised counts\n(rlog)")  # Legend title
)
```

## one heatmap for top of each stage

```{r warning=FALSE}
mean_rlog.df <- left_join(mean_rlog.df, dplyr::select(rbind(naive_smoops.df, epi_smoops.df, diff_smoops.df), gene_name, gene_id),
                          by =c("id" = "gene_id"))
```

Naive:

```{r}
top_naive.df <- mean_rlog.df %>%
  dplyr::select(id, gene_name, contains("naive")) %>%
  dplyr::filter(id %in% union(top_semi_naive.df$gene_id, top_oops_naive.df$gene_id)) %>%
  dplyr::distinct(gene_name, .keep_all = T) %>%
  column_to_rownames(var = "gene_name") %>%
  dplyr::select(-id)

z_scores.top_naive <- t(apply(top_naive.df, 1, scale))

# Convert back to data frame and add gene_id column
z_scores.top_naive.df <- data.frame(z_scores.top_naive) 
colnames(z_scores.top_naive.df) <- colnames(top_naive.df)

h1 <- plot_zscore_heatmap(z_scores.top_naive.df, "naive")
```

Epi: 

```{r}
top_epi.df <- mean_rlog.df %>%
  dplyr::select(id, gene_name, contains("epi")) %>%
  dplyr::filter(id %in% union(top_semi_epi.df$gene_id, top_oops_epi.df$gene_id)) %>%
  dplyr::distinct(gene_name, .keep_all = T) %>%
  column_to_rownames(var = "gene_name") %>%
  dplyr::select(-id)

z_scores.top_epi <- t(apply(top_epi.df, 1, scale))

# Convert back to data frame and add gene_id column
z_scores.top_epi.df <- data.frame(z_scores.top_epi) 
colnames(z_scores.top_epi.df) <- colnames(top_epi.df)

h2 <- plot_zscore_heatmap(z_scores.top_epi.df, "epi")
```

Diff:

```{r}
top_diff.df <- mean_rlog.df %>%
  dplyr::select(id, gene_name, contains("diff")) %>%
  dplyr::filter(id %in% union(top_semi_diff.df$gene_id, top_oops_diff.df$gene_id)) %>%
  dplyr::distinct(gene_name, .keep_all = T) %>%
  column_to_rownames(var = "gene_name") %>%
  dplyr::select(-id)

z_scores.top_diff <- t(apply(top_diff.df, 1, scale))

# Convert back to data frame and add gene_id column
z_scores.top_diff.df <- data.frame(z_scores.top_diff) 
colnames(z_scores.top_diff.df) <- colnames(top_diff.df)

# Create the heatmap with column and row splits
h3 <- plot_zscore_heatmap(z_scores.top_diff.df, "diff")
```

Save heatmaps:

```{r}
# Open a PDF device
pdf("~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/figures/figure_1/naive_top_smoops_heatmap.pdf", width = 3, height = 5)
draw(h1)
# Close the PDF device
dev.off()

pdf("~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/figures/figure_1/epi_top_smoops_heatmap.pdf", width = 3.5, height = 5)
draw(h2)
dev.off()

pdf("~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/figures/figure_1/diff_top_smoops_heatmap.pdf", width = 3, height = 5)
draw(h3)
dev.off()
```


# Heatmap for FISH candidates

Obtain rlog counts

```{r}
fish.df <- fread("~/Dropbox (The Francis Crick)/semi_oops_project_v2/V2/fish_results/FISH_results_expression.csv")

fish.mean_rlog.df <- mean_rlog.df %>%
  dplyr::filter(id %in% fish.df$gene_id) %>%
  column_to_rownames(var = "id") %>%
  dplyr::select(-category)

```


Compute Z-scores row-wise

```{r}
z_scores <- t(apply(fish.mean_rlog.df, 1, scale))

# Convert back to data frame and add gene_id column
mean_rlog.zscore.df <- data.frame(z_scores) 
colnames(mean_rlog.zscore.df) <- colnames(fish.mean_rlog.df)

fish.mean_rlog.zscore.df <- left_join(mean_rlog.zscore.df %>% rownames_to_column(var = "gene_id"),
                                      fish.df %>% dplyr::select(gene_id, rank, gene_name),
                                      by = "gene_id")

fish.mean_rlog.zscore.df$rank <-factor(fish.mean_rlog.zscore.df$rank, 
                                       levels = c("control", "bottom", "middle", "top"))

# Prepare the data matrix
data_matrix <- as.matrix(fish.mean_rlog.zscore.df[, -c(1,5,6)])  # Exclude gene_id and rank columns

# Set row names as gene_id
rownames(data_matrix) <- fish.mean_rlog.zscore.df$gene_name

# Verify the dimensions of the matrix
print(dim(data_matrix))  # Should return rows and 9 columns (3 control, 3 semi, 3 oops)

# Split rows by rank
row_split <- fish.mean_rlog.zscore.df$rank

# Create the heatmap with column and row splits
Heatmap(
  data_matrix, 
  name = "zscore", 
  # top_annotation = column_ha, 
  column_split = factor(rep(c("control", "semi", "OOPS"), each = 1), levels = c("control", "semi", "OOPS")),  # Column split by groups
  row_split = row_split,  # Row split by rank
  cluster_rows = FALSE,  # Disable row clustering
  cluster_columns = FALSE,  # Disable column clustering
  show_row_names = TRUE,  # Show gene names (gene_id)
  show_column_names = F,  # Show column names
  #heatmap_legend_param = list(title = "zscore", title_position = "top")
)
```



